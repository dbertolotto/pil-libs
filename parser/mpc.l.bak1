
(de reduce (Fun Lst Init)
  (if (= NIL Lst)
    Init
    (if (= NIL Init)
      (reduce Fun (cddr Lst) (Fun (car Lst) (cadr Lst)))
      (reduce Fun (cdr Lst) (Fun Init (car Lst))))))

### State

(class +Success)
(dm T (Val State)
  (=: V Val)
  (=: S State))

(de success (Val State)
  (new '(+Success) Val State))

(class +Error)
(dm T (State)
  (=: S State))

(de error (State)
  (new '(+Error) State))

(de error? (Obj)
  (when (isa '(+Error) Obj) T))

(de updates (@F)
  (fill '(State)
    (list State ('@F State))))

(de sets (@S)
  (macro
    (updates '((S) '@S))))

(def 'fetchs
  (updates '((S) S)))

(class +State)
(dm T (Inp Pos Err Exp)
  (=: Inp Inp)
  (=: Pos Pos)
  (=: Err Err)
  (=: Exp Exp))
(dm car> ()
  (car (: Inp)))
(dm cdr> ()
  (cdr (: Inp)))
(dm next> ()
  (let (Cdr (cdr> This)
        NPos (next-pos This))
  (new '(+State) Cdr NPos (: Err) (: Exp))))
(dm r> ()
  (car (: Pos)))
(dm c> ()
  (cdr (: Pos)))
(dm err> (Msg)
  (new '(+State) (: Inp) (: Pos) Msg (: Exp)))
(dm exp> (Msg)
  (new '(+State) (: Inp) (: Pos) (: Err)
    (if (: Exp)
      (cons Msg " >> " @)
      Msg)))
(dm rexp> ()
  (new '(+State) (: Inp) (: Pos) (: Err) '()))
(dm prinl> ()
  (prinl
    (text "@1\n\^-- row: @2, col: @3 - Unexpected '@4'. Expected @5." (pack (head 10 (: Inp))) (car (: Pos)) (cdr (: Pos)) (: Err) (: Exp))))

(de pos (Row Col)
  (cons Row Col))

(de next-pos (State)
  (let (Car (car> State)
        Cdr (cdr> State))
    (cond
      ((and Cdr (or (= Car "\n") (= Car "\r")))
         (pos (inc (r> State)) 1))
      (Cdr (pos (r> State) (inc (c> State))))
      (T (pos -1 -1)))))

(de err? (Res)
  (let State (caadar Res)
    (get State 'Err)))

### Parser

(de resultp (@V)
  (fill '((State)
    (list (success '@V State)))))

(de errorp (@Err)
  (fill '((State)
    (let S (car State)
      (list (list NIL (list (err> S @Err))))))))

(de labelp (@Label @P)
  (fill '((State)
    (let R ('@P State)
      (if (err? R)
        (list (list (caar R) (list (exp> (caadar R) @Label))))
        (list (list (caar R) (list (rexp> (caadar R))))))))))

(def 'itemp
  (fill '((State)
    (let S (car State)
      (if (car> S)
        (list (list (car> S) (list (next> S))))
        (list (list NIL (list (err> S "no more input")))))))))

(de bindp (@P @F)
  (fill '((State)
    (let R ('@P State)
      (ifn (error? R)
        (let (V (caar R)
              S (cadar R))
          (('@F V) S))
        R)))))

(de bind2p (@P1 @P2 @F)
  (eval
    (fill
      '(bindp '@P1
              '((V1)
                (let (@V1 V1
                      F2 (fill '((V2) (resultp ('@F '@V1 V2)))))
                  (bindp '@P2 F2))))
      '(@P1 @P2 @F))))

(de seq2p (P1 P2)
  (bind2p P1 P2 'cons))

(de seqp @
  (reduce 'seq2p (rest)))

(de satp (@Pred)
  (macro
    (bindp 'itemp
           '((X)
             (cond
               ((= X NIL) (errorp "no more input"))
               (('@Pred X) (resultp X))
               (T (errorp (text "@1" X))))))))

(de mapp (@Fn @P)
  (macro
    (bindp '@P '((V) (resultp ('@Fn V))))))

(de charp (@C)
  (macro
    (labelp (text "char '@1'" @C)
      (satp '((X) (= @C X))))))

(def 'digitp
  (labelp "digit"
    (satp '((X) (and (>= X "0") (<= X "9"))))))

(def 'lowerp
  (satp '((X) (and (>= X "a") (<= X "z")))))

(def 'upperp
  (satp '((X) (and (>= X "A") (<= X "Z")))))

(def 'hexlowerp
  (satp '((X) (and (>= X "a") (<= X "f")))))

(def 'hexupperp
  (satp '((X) (and (>= X "A") (<= X "F")))))

(de merge (R1 R2)
  (list (list (caar R2) (append (cadar R2) (cadar R1)))))

(de plus2p (@P1 @P2)
  (fill '((State)
    (let R1 ('@P1 State)
      (if (err? R1)
        (let R2 ('@P2 State)
          (if (err? R2)
            (merge R1 R2)
            R2))
        R1)))))

(de plusp @
  (reduce 'plus2p (rest)))

(def 'letterp
  (plusp 'lowerp 'upperp))

(def 'alphanump
  (labelp "alphanumeric"
    (plusp 'letterp 'digitp)))

(def 'hexletterp
  (plusp 'hexlowerp 'hexupperp))

(def 'hexp
  (labelp "hexadecimal"
    (plusp 'hexletterp 'digitp)))

(de stringp (String)
  (let Stream (if (atom String) (chop String) String)
    (if Stream
      (mapp 'pack (seqp (charp (car Stream)) (stringp (cdr Stream))))
      (resultp ""))))

(de manyp (@P)
  (fill '((State)
    ((plusp (seqp '@P (manyp '@P)) (resultp '())) State))))

(def 'wordp
  (mapp 'pack (manyp 'letterp)))

(def 'identp
  (seqp 'lowerp (manyp 'alphanump)))

(de many1p (P)
  (seqp P (manyp P)))

(def 'natp
  (bindp (many1p 'digitp) '((X) (resultp (format X)))))

(def 'intp
  (bindp (seqp (plusp (charp "-") (charp "+") (resultp "")) (many1p 'digitp))
         '((V) (resultp (format (pack V))))))

(def 'spacep
  (labelp "whitespace"
    (satp '((X) (member X '(" " "\t" "\n" "\r"))))))

(def 'spacesp
  (manyp 'spacep))

(de droplp (P1 P2)
  (bind2p P1 P2 '((V1 V2) V2)))

(de droprp (P1 P2)
  (bind2p P1 P2 '((V1 V2) V1)))

(de sepby1p (P Sep)
  (seqp P (manyp (droplp Sep P))))

(de betweenp (Open P Close)
  (droplp Open (droprp P Close)))

(de sepbyp (P Sep)
  (plusp (sepby1p P Sep) (resultp '())))

(def 'intsp
  (betweenp (charp "[") (sepby1p 'intp (charp ",")) (charp "]")))

(de ignorep (@P @W)
  (macro
    (bindp '@P '((V) (resultp '@W)))))

(de optp (P)
  (plusp P (resultp '())))

### JSON

(def 'jnull
  (labelp "jnull"
    (mapp 'any (stringp "null"))))

(def 'jtrue
  (labelp "jtrue"
    (mapp 'any (stringp "true"))))

(def 'jfalse
  (labelp "jfalse"
    (mapp 'any (stringp "false"))))

(def 'junesc
  (satp '((X) (not (or (= X "\\") (= X "\""))))))

(setq *Jesc
  (list
    '("\\\"" . "\"")
    '("\\\\" . "\\")
    '("\\/" . "/")
    '("\\b" . `(char (hex "232B")))
    '("\\f" . `(char (hex "240A")))
    '("\\n" . "\n")
    '("\\r" . "\r")
    '("\\t" . "\t")
    ))

(def 'jesc
  (apply 'plusp (mapcar '((X) (ignorep (stringp (car X)) (cdr X))) *Jesc)))

(def 'juni
  (let (bl (charp "\\")
        uc (charp "u")
        hx (seqp hexp hexp hexp hexp)
        code (mapp 'char (mapp 'hex (mapp 'pack hx))))
    (droplp bl (droplp uc code))))

(def 'jchar
  (plusp 'junesc 'jesc 'juni))

(de handle-empty-string (S)
  (if S S 'nils))

(def 'jstring
  (let (quotep (charp "\"")
        manych (mapp 'pack (manyp 'jchar)))
    (labelp "jstring"
      (mapp 'handle-empty-string
            (betweenp quotep manych quotep)))))

(de to-num (Sign Int Frac SignExp Exp)
  (let (Expn (format Exp)
        ExpVal (case Expn
                 (NIL 1)
                 (0 1)
                 (T (apply * (need Expn 10))))
        ExpScl (if (= SignExp "-") Expn 0)
        FracScl (length Frac))
    (scl (max *Scl (+ FracScl ExpScl)))
    (let (Num (format (pack Sign Int "." Frac) *Scl)
          op (if (= SignExp "-") '/ '*))
      (op Num ExpVal))))

(def 'jdigit19
  (satp '((X) (and (>= X "1") (<= X "9")))))

(def 'jsign
  (plusp (charp "+") (charp "-") (resultp "")))

(def 'jint
  (seqp 'jsign
        (mapp 'pack (plusp (charp "0")
                           (seqp 'jdigit19 (manyp digitp))))))

(def 'jfrac
  (droplp (charp ".")
          (mapp 'pack (many1p digitp))))

(def 'jexp
  (droplp (plusp (charp "e") (charp "E"))
          (seqp 'jsign
                (mapp 'pack (many1p digitp)))))

(def 'jnum
  (seqp 'jint (optp 'jfrac) (optp 'jexp)))

(def 'jnumber
  (labelp "jnumber"
    (mapp '((X) (apply 'to-num X))
          (mapp '((X) (fish atom X)) 'jnum))))

(de to-array (Lst)
  (append '(T) Lst))

(def 'jarray
  (let (left (droprp (charp "[") 'spacesp)
        right (droprp (charp "]") 'spacesp)
        comma (droprp (charp ",") 'spacesp)
        value (droprp 'jvalue 'spacesp)
        values (sepbyp value comma))
    (labelp "jarray"
      (mapp 'to-array (betweenp left values right)))))

(def 'jobject
  (let (left (droprp (charp "{") 'spacesp)
        right (droprp (charp "}") 'spacesp)
        comma (droprp (charp ",") 'spacesp)
        colon (droprp (charp ":") 'spacesp)
        key (droprp 'jstring 'spacesp)
        value (droprp 'jvalue 'spacesp)
        keyval (seqp (droprp key colon) value)
        keyvals (sepbyp keyval comma))
    (labelp "jobject"
      (betweenp left keyvals right))))

(def 'jvalue
  (plusp 'jobject 'jarray 'jstring 'jnumber 'jtrue 'jfalse 'jnull))

(de parse (P String)
  ((droplp 'spacesp P) (list (new '(+State) (chop String) (pos 1 1)))))

(de read-file (Path)
  (in Path (till NIL T)))

(setq ex01 (read-file "ex01.json"))
(setq ex02 (read-file "ex02.json"))
(setq ex03 (read-file "ex03.json"))
(setq ex04 (read-file "ex04.json"))
(setq ex05 (read-file "ex05.json"))
(setq test02 (read-file "test02.json"))
